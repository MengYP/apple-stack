//: Playground - noun: a place where people can play

import UIKit

var str = "Hello, 基本运算符 Basic Operators"


    
//1. 赋值运算符
/*
 赋值运算符( a = b )：表示用 b 的值来初始化或更新 a 的值。
 
 注意：
 （1）赋值符( = )不返回值, 以防止把想要判断相等运算符( == )的地方写成赋值符导致的错误。
 
 （2）如果赋值的右边是一个多元组,它的元素可以马上被分解成多个常量或变量。
 
 */

let (x, y) = (1, 2)
x  //x=1
y  //y=2

//与 C 语言和 Objective-C 不同,Swift 的赋值操作并不返回任何值。所以以下代码是错误的：
//if x = y {}  //语句错误：因为 x = y 并不返回任何值




//2. 算术运算符
/*
 算术运算符( + , - , * , / , % 等)会检测并不允许值溢出,
 以此来避免保存变量时,由于变量大于或小于其类型所能承载的范围时导致的异常结果。
 
 当然允许你使用 Swift 的溢出运算符(&+)来实现溢出。
 */

9 % 4
-9 % 4



//3. 组合赋值运算符
/*
 复合赋值运算没有返回值, let b = a += 2 这类代码是错误。
 */

var a = 1
a += 2


//4. 比较运算符
/*
 Swift 也提供恒等( === )和不恒等( !== )这两个比较符来判断两个对象是否引用同一个对象实例。
 
 （==、 !=、 >、 <、 >=、 <=、 ===、 !=）
 
 每个比较运算都返回了一个标识表达式是否成立的布尔值。
 
 Int、String、元组(值是可比较的)。
 Bool 不能被比较。
 
 Swift 标准库只能比较七个以内元素的元组比较函数。
 如果你的元组元素超过七个时,你需要自己实现比较运算符。
 */

1 == 1 // Int 类型
1 > 2

let name = "world" //证明：String 类型不是对象，是 struct类型
if name == "world" {
    print("hello , world")
}

(1, "accdddd") < (2, "b")  //元组
//比较元组大小会按照从左到右、逐值比较的方式, 直到发现有两个值不等时停止。 如果所有的值都相等,那么这一对元组我们就称它们是相等的。

//(1, false) < (2, true)   //报错，元组中的值都可以比较，元组才能比较。

(1,2,3,4,5,6) == (1,2,3,4,5,6)        //七个以内
//(1,2,3,4,5,6,7) == (1,2,3,4,5,6,7)  //报错



//5. 三目运算符
/*
  高效、便捷表达二选一的选择。
 
  问题 ? 答案 1 : 答案 2
 */
let contentHeight = 40
let hasHeader = true
let rowHeight = contentHeight + (hasHeader ? 50 : 20)





//6. 空合运算符
/*
 空合运算符   Nil Coalescing Operator
    
 a ?? b
 （1）a 必须为可选类型（Optional）;
 （2）b 类型必须 和 a 存储值类型一致；
 （3）对a进行空判断，如果 a 包含一个值就进行解封，否则就返回一个默认值b。
    相当于代码 a != nil ? a! : b 的简短表达。
 
 （4）注意: 如果 a 为非空值( non-nil ),那么值 b 将不会被计算。
     这也就是所谓的短路求值。
 */
var aa: String? = "world"
let bb = "Default" //bb 类型必须 和 aa 存储值类型一致
//aa = nil
aa ?? bb

//相当于：
aa != nil ? aa! : bb
/*
 解释：
    当可选类型 a 的值不为空时,进行强制解封(a!),访问 a 中的值;
    反之返 回默认值 b 。
 
 无疑空合运算符( ?? )提供了一种更为优雅的方式 去封装条件判断 和 解封两种行为, 显得简洁以及更具可读性。
 */




//7. 区间运算符

/*
    a...b   闭区间运算符
    a..<b   半开区间运算符（前闭后开）。 方便从 0 开始的列表。
 
 */



//8. 逻辑运算符
/*
 Logical Operators
 
 操作对象：逻辑布尔值
 
 （!  &&  ||）
 短路计算(short-circuit evaluation)
 */

!true
true && false  //第一个值为 false ,第二个值不再计算，短路
false || true  //第一个值为 true ,第二个值不再计算，短路










